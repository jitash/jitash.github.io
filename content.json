{"pages":[{"title":"about me","text":"it is me, a lucky dog","link":"/about/index.html"}],"posts":[{"title":"Android Activity启动模式","text":"Android软件体系架构Android软件体系结构 Tasks Task (属于操作系统，不属于application)查看Tasks Menu键 adb shell dumpsys activity activities | sed -En -e ‘/Stack #/p’ -e ‘/Running activities/,/Run #0/p’ Task的启动方式 新建 通知 系统 自己 scheme 第三方应用 恢复（activity 由不可见到获得焦点） navigation启动 back按键 标题栏back按钮 launcher启动 Task不存在 Task已存在Activity&amp;Fragment的生命周期fragment Activity生命周期 相邻状态之间的区别ActivityA-&gt;ActivityB onPauseA -&gt; onCreateB -&gt; onStartB -&gt; onResumeB -&gt; onStopA ActivityB-&gt;ActivityA onPauseB -&gt; onRestartA -&gt; onStartA -&gt; onResumeA -&gt; onStopB onCreate 和 onStart 可见与不可见。 执行的次数。onCreate只在Activity创建的时候执行一次；onStart在Activity切换和Home键返回桌面在切换回来的过程中被多次调用，所以Bundle的数据回复在onStart中进行比在onStart中更合适。 onCreate中能做的onStart都可以做，但在onStart中的事onCreate未必能做。eg：动画的初始化在onStart中比较好。 onStart 和 onResume 是否在前台 职责不同，onStart负责初始化的工作，onResume负责动画的开启和设备独占的操作。 onPause 和 onStop 是否可见 系统内存不足的时候可能不会执行onStop，so 程序状态的保存、独占设备和动画的关闭、以及一些数据的保存最好在onPause中进行，但是不能进行耗时操作。 onStop 和 onDestroy nStop时对象还在内存中，此时可以切换回该Activity onDestroy时Activity已经被销毁。 onNewIntent生命周期 只对singleTop，singleTask，singleInstance有效，因为每次都是新建。 只对startActivity有效。 Standard等4种启动模式standard 系统在启动Activity的Task中创建Activity的新实例并向其传送Intent。 从非Activity的context启动时，需要带上NEW_TASK的flag； 当启动一个带有affinity的Activity时，如果已经有实例在该Task中，则不会重新创建； 如果从应用内启动的standard activity的affinity就是App默认的affinity（即应用包名），则每次新建一个实例；singleTop 栈顶有相同实例时，Intent不会重新创建Activity而是通过onNewIntent被发送到现有的Activity 123456789101112存在需要启动的Activity的Affinity的Task？ -Y-&gt; 在栈顶？ -Y-&gt; 直接调用栈顶Activity的onNewIntent | | | N | |-&gt; 在栈顶创建Activity N |-&gt; 在栈顶？ -Y-&gt; 直接调用栈顶Activity的onNewIntent | N |-&gt; 带有NEW_TASK的标记？ -Y-&gt; 创建启动Activity的affinity的Task，创建Activity | N |-&gt; 在当前的Task栈顶创建Activity singleTask 和SingleTop类似，栈中是否有实例？ affinity是否存在？affinity中是否有实例？栈中有实例启动的时候pop上面的实例，直至移动到栈顶 singleInstance 和singleTask相同，系统不会将其他Activity启动到它的Task中，此种Activity有且仅有一个存在于一个栈中 Intent Activity Flag Task创建 NEW_TASK MULTIPLE_TASK NEW_DOCUMENT 确定了Task后对它的操作 CLEAR_TASK CLEAT_TOP SINGLE_TOP REORDER_TO_FRONT 启动的标志设置 NO_USER_ACTION LAUNCHED_FROM_HISTORY 启动的过程设置 NO_ANIMATION 返回的地方 TASK_ON_HOME FROWARD_RESULT 返回后的状态 EXCLUDE_FROM_RECENTS RETAIN_IN_RECENTS NO_HISTORY 启动模式应用场景 singleTop 适合启动同类型的Activity，eg：接收通知启动的内容显示页面、耗时操作返回页面、登录页面 singleTask 适合作为程序入口，eg：WebView页面、扫一扫页面、确认订单界面、付款界面 singleInstance 适合需要与程序分开的分离开的页面，eg：闹铃的响铃界面、来电页面、锁屏页","link":"/2020/03/18/Android-Activity%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/"},{"title":"Java中的泛型","text":"为什么需要泛型","link":"/2020/03/22/Java%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B/"},{"title":"hexo 简单命令","text":"12345$ hexo g #生成静态文件 generate$ hexo clean #清除缓存$ hexo d #提交并推送到远端仓库 deploy$ hexo s #调试模式server $ hexo s --debug #调试debug模式","link":"/2020/03/17/hexo-%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4/"},{"title":"怎么学习","text":"1）记忆宫殿​ 这是一个记忆的技巧，还是福尔摩斯带火的。 方法就是，把你记住的东西和特定物品联系起来，这样你在回想的时候，会联想到这个物品，会想到那天都发生了什么，整个脉络都会变得清楚。 记忆宫殿的核心就是通过各种方法触发你对某件事物的回忆，把它们从茫茫大海般的记忆中揪出来。 2）门徒效应​ 把每次学习都当作派下来的任务，这个任务就是，你要教会其他学生。 如果你变成老师，你会怎么教学生呢？ 有研究表明，当你在教别人一个知识时，你必须更努力地学习，这样你才可以更准确地回想起它，更有效地运用它，才能保证你的知识面可以覆盖住所有学生可能提出的问题。 这种方法被称为「深度处理」。 3）学习策略​ 这条就很切题了，只是视频没有给出最终的答案。但是我们还是明白了，聪明的学生都热衷于有效的学习策略，而学习吃力的学生却深陷在无效的学习方法中。而我曾经就是那个吃力的学生。 4）蔡加尼克效应​ 这个名词的意思就是对于已经完成的任务，人们更容易记住那些「未完待续」的任务，因为当我们开始一项任务然后打断它时，会产生一种对任务的特定紧张感，这种紧张感会提升你的认知功能。 「番茄工作法」由此诞生。每当你工作25分钟，就休息5分钟，接着再工作25分钟，休息5分钟。学习亦然。这个学习方法也被称为「分散式学习」。","link":"/2020/03/16/%E6%80%8E%E4%B9%88%E5%AD%A6%E4%B9%A0/"},{"title":"设计模式","text":"设计模式六大原则 单一职责原则（一个类只负责一个职责） 里氏替换原则（子类可以扩展父类功能，但不要改变父类原有的功能） 依赖倒置原则（面向接口编程） 接口隔离原则（设计接口功能尽可能细粒度，最小功能单元） 迪米特法则（降低耦合-局部变量中不要引入新的类） 开闭原则（对扩展开放，对修改关闭） 创建型模式静态工厂 把素有对象的创建逻辑集中到一个类里处理 工厂方法模式 一个工厂负责一个产品类的创建 抽向工厂模式 将一个系列的产品的工厂合并成一个工厂，负责生产这个系列的产品 单例模式 饿汉式 懒汉式 双重校验锁DCL 静态内部类 建造者模式 对象的创建比较复杂时，按步骤一块块创建，让创建的过程模板化 结构性模式 继承与组合，优先使用组合 桥接模式适配器模式装饰器模式 动态的给一个对象增加一些额外的职责，为的是功能增强 代理模式 一个类代表另一个类的功能组合模式 行为型模式模板方法模式策略模式 通过策略模式执行不同的算法分支。核心是通过注入对象，改变行为观察者模式 一个对象状态改变时通知其他对象，为的是尽量弱化对象间的依赖责任链模式 将请求床给一个接收者链，由链将强求流转给目标对象命令模式访问者模式","link":"/2020/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"FrameWork","slug":"FrameWork","link":"/tags/FrameWork/"},{"name":"Activity","slug":"Activity","link":"/tags/Activity/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"泛型","slug":"泛型","link":"/tags/%E6%B3%9B%E5%9E%8B/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Learn","slug":"Learn","link":"/tags/Learn/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"笔记本","slug":"笔记本","link":"/categories/%E7%AC%94%E8%AE%B0%E6%9C%AC/"},{"name":"开发者手册","slug":"开发者手册","link":"/categories/%E5%BC%80%E5%8F%91%E8%80%85%E6%89%8B%E5%86%8C/"},{"name":"Java","slug":"笔记本/Java","link":"/categories/%E7%AC%94%E8%AE%B0%E6%9C%AC/Java/"}]}